
import UIKit
import AVFoundation
import MediaPlayer

class NewAudioPlayerViewController: UIViewController {
    // MARK: - Data Properties
    var newsItem: TopChoiceItem?
    var transcriptIndex: Int = 0
    private var isTranscriptVisible = false
    private var fullArticleContent: String = ""
    
    // MARK: - Playback State
    private var isPlaying = false
    private var currentTime: Float = 0.0
    private var duration: Float = 180.0
    private var currentVolume: Float = 0.7
    
    private var playbackTimer: Timer?
    private var allBriefs: [TopChoiceItem] = []
    private var currentBriefIndex: Int = 0
    
    // MARK: - AVFoundation
    private let speechSynthesizer = AVSpeechSynthesizer()
    private var currentUtterance: AVSpeechUtterance?
    private var audioSession: AVAudioSession?
    
//    // MARK: - UI Components
//    private let blurView = UIVisualEffectView(effect: UIBlurEffect(style: .systemThinMaterialLight))
//    private let transcriptBox = UIView()
//    private let transcriptBlur = UIVisualEffectView(effect: UIBlurEffect(style: .systemUltraThinMaterialLight))
//    private let albumArtContainer = UIView()
//    private let albumArt = UIImageView()
//    private let titleLabel = UILabel()
//    private let sourceLabel = UILabel()
//    private let playbackSlider = UISlider()
//    private let currentTimeLabel = UILabel()
//    private let remainingTimeLabel = UILabel()
//    private let playPauseBtn = UIButton()
//    private let backwardBtn = UIButton()
//    private let forwardBtn = UIButton()
//    private let volumeSlider = UISlider()
//    private let transcriptToggle = UIButton()
//    private let transcriptTextView = UITextView()
//    private let moreBtn = UIButton()
    // MARK: - UI Components (Clean UI without Gradients)
    private let transcriptBox = UIView()
    private let albumArtContainer = UIView()
    private let albumArt = UIImageView()
    private let titleLabel = UILabel()
    private let sourceLabel = UILabel()
    private let playbackSlider = UISlider()
    private let currentTimeLabel = UILabel()
    private let remainingTimeLabel = UILabel()
    private let playPauseBtn = UIButton()
    private let backwardBtn = UIButton()
    private let forwardBtn = UIButton()
    private let volumeSlider = UISlider()
    private let transcriptToggle = UIButton()
    private let transcriptTextView = UITextView()
    private let moreBtn = UIButton()

    override func viewDidLoad() {
        super.viewDidLoad()
        setupAudioSession()
        setupData()
        setupAestheticUI()
        setupActions()
        updateUI()
        
        speechSynthesizer.delegate = self
    }
    
    // MARK: - Setup Methods
    
    private func setupAudioSession() {
        audioSession = AVAudioSession.sharedInstance()
        do {
            try audioSession?.setCategory(.playback, mode: .spokenAudio, options: [])
            try audioSession?.setActive(true)
        } catch {
            print("Failed to set up audio session: \(error)")
        }
    }
    
    private func loadArticleContent() {
        guard let item = newsItem else {
            fullArticleContent = AudioDataStore.shared.getFullTranscript(for: transcriptIndex)
            return
        }
        fullArticleContent = AudioDataStore.shared.getArticleContent(for: item, fallbackIndex: transcriptIndex)
    }
    
    private func calculateDuration() {
        let words = fullArticleContent.components(separatedBy: .whitespacesAndNewlines).count
        let estimatedSeconds = Float(words) / 2.5
        self.duration = max(estimatedSeconds, 30.0)
        playbackSlider.maximumValue = self.duration
    }
    
    private func startSpeech() {
        if speechSynthesizer.isPaused {
            speechSynthesizer.continueSpeaking()
        } else {
            if fullArticleContent.isEmpty { return }

            let utterance = AVSpeechUtterance(string: fullArticleContent)
            utterance.voice = AVSpeechSynthesisVoice(language: "en-US") ?? AVSpeechSynthesisVoice(language: AVSpeechSynthesisVoice.currentLanguageCode())
            utterance.rate = 0.5
            utterance.pitchMultiplier = 1.0
            utterance.volume = currentVolume
            
            speechSynthesizer.speak(utterance)
        }
    }

    private func pauseSpeech() {
        if speechSynthesizer.isSpeaking {
            speechSynthesizer.pauseSpeaking(at: .immediate)
        }
    }

    private func stopSpeech() {
        speechSynthesizer.stopSpeaking(at: .immediate)
        setupTranscriptBox()
    }
    
    private func setupData() {
        allBriefs = AudioDataStore.shared.topChoices
        
        if let item = newsItem {
            if let index = allBriefs.firstIndex(where: { $0.title == item.title }) {
                currentBriefIndex = index
                transcriptIndex = index
            } else {
                currentBriefIndex = transcriptIndex
            }
        }
        
        loadArticleContent()
        calculateDuration()
    }
    
    private func setupAestheticUI() {
        let brandIndigo = UIColor(red: 0.40, green: 0.52, blue: 0.89, alpha: 1.0)
        view.backgroundColor = .systemBackground
        
        // Removed Gradient logic
        
//        blurView.frame = view.bounds
//        blurView.alpha = 0.3
//        view.addSubview(blurView)
        
        setupTranscriptBox()
        
        albumArtContainer.backgroundColor = .secondarySystemBackground
        albumArtContainer.layer.cornerRadius = 20
        albumArtContainer.layer.shadowColor = UIColor.black.cgColor
        albumArtContainer.layer.shadowOpacity = 0.15
        albumArtContainer.layer.shadowOffset = CGSize(width: 0, height: 10)
        albumArtContainer.layer.shadowRadius = 20
        
        albumArt.layer.cornerRadius = 20
        albumArt.clipsToBounds = true
        albumArt.contentMode = .scaleAspectFill
        albumArt.image = UIImage(systemName: "waveform.circle.fill")
        albumArt.tintColor = brandIndigo
        
        titleLabel.text = newsItem?.title ?? "Technical Brief"
        titleLabel.font = .systemFont(ofSize: 22, weight: .bold)
        titleLabel.numberOfLines = 2
        titleLabel.lineBreakMode = .byTruncatingTail
        
        sourceLabel.text = newsItem?.date ?? "25 OCT 25"
        sourceLabel.textColor = .secondaryLabel
        
        currentTimeLabel.font = .systemFont(ofSize: 12, weight: .medium)
        currentTimeLabel.textColor = .secondaryLabel
        currentTimeLabel.text = "0:00"
        
        remainingTimeLabel.font = .systemFont(ofSize: 12, weight: .medium)
        remainingTimeLabel.textColor = .secondaryLabel
        remainingTimeLabel.textAlignment = .right
        remainingTimeLabel.text = String(format: "-%d:%02d", Int(duration) / 60, Int(duration) % 60)
        
        setupButtons(brandColor: brandIndigo)
        
        let dismissIcon = UIButton(type: .system)
        dismissIcon.setImage(UIImage(systemName: "chevron.compact.down"), for: .normal)
        dismissIcon.tintColor = .systemGray2
        dismissIcon.addTarget(self, action: #selector(dismissPlayer), for: .touchUpInside)
        
        // Removed shuffleBtn and repeatBtn from subviews
        [dismissIcon, albumArtContainer, titleLabel, sourceLabel,
         currentTimeLabel, remainingTimeLabel, playbackSlider,
         playPauseBtn, backwardBtn, forwardBtn,
         volumeSlider, moreBtn, transcriptToggle].forEach {
            $0.translatesAutoresizingMaskIntoConstraints = false
            view.addSubview($0)
        }
        
        albumArtContainer.addSubview(albumArt)
        albumArt.translatesAutoresizingMaskIntoConstraints = false
        
        setupConstraints(dismissIcon: dismissIcon)
    }
    
    func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, willSpeakRangeOfSpeechString characterRange: NSRange, utterance: AVSpeechUtterance) {
        let fullText = utterance.speechString
        let attributedString = NSMutableAttributedString(string: fullText)
        
        attributedString.addAttributes([
            .foregroundColor: UIColor.label.withAlphaComponent(0.25),
            .font: UIFont.systemFont(ofSize: 28, weight: .medium)
        ], range: NSRange(location: 0, length: fullText.count))
        
        attributedString.addAttributes([
            .foregroundColor: UIColor.label.withAlphaComponent(0.7)
        ], range: NSRange(location: 0, length: characterRange.location))
        
        attributedString.addAttributes([
            .foregroundColor: UIColor.label,
            .font: UIFont.systemFont(ofSize: 28, weight: .bold)
        ], range: characterRange)
        
        DispatchQueue.main.async {
            self.transcriptTextView.attributedText = attributedString
            self.transcriptTextView.scrollRangeToVisible(characterRange)
            
            let totalLength = Float(fullText.count)
            let progress = (Float(characterRange.location) / totalLength) * self.duration
            self.currentTime = progress
            self.playbackSlider.value = progress
            self.updateTimeLabels()
        }
    }

    private func setupTranscriptBox() {
        transcriptBox.alpha = 0
        transcriptBox.backgroundColor = .clear
        
        transcriptTextView.backgroundColor = .clear
        transcriptTextView.textColor = .label
        transcriptTextView.font = .systemFont(ofSize: 28, weight: .semibold)
        transcriptTextView.isEditable = false
        transcriptTextView.isScrollEnabled = true
        transcriptTextView.showsVerticalScrollIndicator = false
        
        view.addSubview(transcriptBox)
        transcriptBox.addSubview(transcriptTextView)
        
        transcriptBox.translatesAutoresizingMaskIntoConstraints = false
        transcriptTextView.translatesAutoresizingMaskIntoConstraints = false
        
        transcriptTextView.attributedText = NSAttributedString(
            string: fullArticleContent,
            attributes: [
                .foregroundColor: UIColor.label.withAlphaComponent(0.3),
                .font: UIFont.systemFont(ofSize: 28, weight: .semibold)
            ]
        )
    }
    
    private func setupButtons(brandColor: UIColor) {
        let mainConfig = UIImage.SymbolConfiguration(pointSize: 54, weight: .semibold)
        let sideConfig = UIImage.SymbolConfiguration(pointSize: 32, weight: .semibold)
        
        playPauseBtn.setImage(UIImage(systemName: "play.fill", withConfiguration: mainConfig), for: .normal)
        playPauseBtn.tintColor = brandColor
        
        backwardBtn.setImage(UIImage(systemName: "backward.fill", withConfiguration: sideConfig), for: .normal)
        forwardBtn.setImage(UIImage(systemName: "forward.fill", withConfiguration: sideConfig), for: .normal)
        
        transcriptToggle.setImage(UIImage(systemName: "quote.bubble"), for: .normal)
        moreBtn.setImage(UIImage(systemName: "ellipsis.circle.fill"), for: .normal)
        
        playbackSlider.minimumTrackTintColor = brandColor
        playbackSlider.maximumValue = duration
        playbackSlider.value = 0
        
        volumeSlider.minimumValueImage = UIImage(systemName: "speaker.fill")
        volumeSlider.maximumValueImage = UIImage(systemName: "speaker.wave.3.fill")
        volumeSlider.minimumTrackTintColor = .systemGray3
        volumeSlider.value = currentVolume
        
        [backwardBtn, forwardBtn, moreBtn, volumeSlider, transcriptToggle].forEach {
            $0.tintColor = .label
        }
    }
    
    private func setupActions() {
        playPauseBtn.addTarget(self, action: #selector(playPauseTapped), for: .touchUpInside)
        backwardBtn.addTarget(self, action: #selector(previousTrack), for: .touchUpInside)
        forwardBtn.addTarget(self, action: #selector(nextTrack), for: .touchUpInside)
        transcriptToggle.addTarget(self, action: #selector(toggleTranscript), for: .touchUpInside)
        moreBtn.addTarget(self, action: #selector(showMoreOptions), for: .touchUpInside)
        
        playbackSlider.addTarget(self, action: #selector(sliderValueChanged), for: .valueChanged)
        playbackSlider.addTarget(self, action: #selector(sliderTouchBegan), for: .touchDown)
        playbackSlider.addTarget(self, action: #selector(sliderTouchEnded), for: [.touchUpInside, .touchUpOutside])
        
        volumeSlider.addTarget(self, action: #selector(volumeChanged), for: .valueChanged)
    }
    
    // MARK: - Playback Control Actions
    @objc private func playPauseTapped() {
        isPlaying.toggle()
        UIImpactFeedbackGenerator(style: .medium).impactOccurred()
        
        let config = UIImage.SymbolConfiguration(pointSize: 50, weight: .semibold)
        let icon = isPlaying ? "pause.fill" : "play.fill"
        playPauseBtn.setImage(UIImage(systemName: icon, withConfiguration: config), for: .normal)
        
        if isPlaying {
            startPlayback()
            startSpeech()
        } else {
            stopPlayback()
            pauseSpeech()
        }
    }
    
    @objc private func previousTrack() {
        UIImpactFeedbackGenerator(style: .medium).impactOccurred()
        
        if currentTime > 3.0 {
            currentTime = 0
            playbackSlider.value = 0
            updateTimeLabels()
            return
        }
        
        if currentBriefIndex > 0 {
            currentBriefIndex -= 1
        } else {
            return
        }
        
        loadNewTrack()
    }
    
    @objc private func nextTrack() {
        UIImpactFeedbackGenerator(style: .medium).impactOccurred()
        
        if currentBriefIndex < allBriefs.count - 1 {
            currentBriefIndex += 1
        } else {
            return
        }
        
        loadNewTrack()
    }
    
    @objc private func toggleTranscript() {
        isTranscriptVisible.toggle()
        UIImpactFeedbackGenerator(style: .medium).impactOccurred()
        
        UIView.animate(withDuration: 0.6, delay: 0, usingSpringWithDamping: 0.85, initialSpringVelocity: 0.5, options: .curveEaseInOut) {
            self.transcriptBox.alpha = self.isTranscriptVisible ? 1 : 0
            self.transcriptBox.transform = self.isTranscriptVisible ? .identity : CGAffineTransform(scaleX: 0.9, y: 0.9)
            
            self.albumArtContainer.alpha = self.isTranscriptVisible ? 0.05 : 1
            self.albumArtContainer.transform = self.isTranscriptVisible ? CGAffineTransform(scaleX: 0.7, y: 0.7) : .identity
            
            self.transcriptToggle.tintColor = self.isTranscriptVisible ? .systemBlue : .label
        }
    }
    
    @objc private func showMoreOptions() {
        UIImpactFeedbackGenerator(style: .light).impactOccurred()
        
        let alert = UIAlertController(title: newsItem?.title, message: nil, preferredStyle: .actionSheet)
        alert.addAction(UIAlertAction(title: "Add to Favorites", style: .default) { _ in })
        alert.addAction(UIAlertAction(title: "Share", style: .default) { _ in })
        alert.addAction(UIAlertAction(title: "View Full Article", style: .default) { _ in
            self.showFullTranscript()
        })
        alert.addAction(UIAlertAction(title: "Cancel", style: .cancel))
        present(alert, animated: true)
    }
    
    private func showFullTranscript() {
        let transcriptVC = TechnicalTranscriptViewController()
        transcriptVC.newsItem = allBriefs[currentBriefIndex]
        transcriptVC.transcriptIndex = currentBriefIndex
        transcriptVC.fullArticleContent = fullArticleContent
        
        let navVC = UINavigationController(rootViewController: transcriptVC)
        present(navVC, animated: true)
    }
    
    // MARK: - Slider Actions
    @objc private func sliderValueChanged(_ sender: UISlider) {
        currentTime = sender.value
        updateTimeLabels()
    }
    
    @objc private func sliderTouchBegan() {
        if isPlaying { pauseSpeech() }
    }
    
    @objc private func sliderTouchEnded() {
        if isPlaying {
            stopSpeech()
            currentTime = playbackSlider.value
            
            if currentTime >= duration - 5 {
                handleTrackEnd()
            } else {
                startSpeech()
            }
        }
    }
    
    @objc private func volumeChanged(_ sender: UISlider) {
        currentVolume = sender.value
        for view in MPVolumeView().subviews {
            if let slider = view as? UISlider {
                DispatchQueue.main.async { slider.value = sender.value }
                break
            }
        }
    }
    
    @objc private func dismissPlayer() {
        stopPlayback()
        stopSpeech()
        dismiss(animated: true)
    }
    
    // MARK: - Playback Management
    private func startPlayback() {
        playbackTimer?.invalidate()
        playbackTimer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) { [weak self] _ in
            guard let self = self else { return }
            self.currentTime += 0.1
            if self.currentTime >= self.duration {
                self.handleTrackEnd()
            } else {
                self.playbackSlider.value = self.currentTime
                self.updateTimeLabels()
            }
        }
    }
    
    private func stopPlayback() {
        playbackTimer?.invalidate()
        playbackTimer = nil
    }
    
    private func handleTrackEnd() {
        if currentBriefIndex < allBriefs.count - 1 {
            nextTrack()
        } else {
            isPlaying = false
            currentTime = 0
            playbackSlider.value = 0
            updateTimeLabels()
            
            let config = UIImage.SymbolConfiguration(pointSize: 50, weight: .semibold)
            playPauseBtn.setImage(UIImage(systemName: "play.fill", withConfiguration: config), for: .normal)
            stopPlayback()
            stopSpeech()
        }
    }
    
    private func loadNewTrack() {
        stopPlayback()
        stopSpeech()
        
        newsItem = allBriefs[currentBriefIndex]
        transcriptIndex = currentBriefIndex
        currentTime = 0
        
        loadArticleContent()
        calculateDuration()
        
        playbackSlider.value = 0
        updateUI()
        
        if isPlaying {
            startPlayback()
            startSpeech()
        }
    }
    
    private func updateUI() {
        titleLabel.text = newsItem?.title ?? "Technical Brief"
        sourceLabel.text = newsItem?.date ?? "Date"
        
        transcriptTextView.attributedText = NSAttributedString(
            string: fullArticleContent,
            attributes: [
                .foregroundColor: UIColor.label.withAlphaComponent(0.3),
                .font: UIFont.systemFont(ofSize: 28, weight: .semibold)
            ]
        )
        
        updateTimeLabels()
    }
    
    private func updateTimeLabels() {
        let current = Int(currentTime)
        let remaining = Int(duration - currentTime)
        currentTimeLabel.text = String(format: "%d:%02d", current / 60, current % 60)
        remainingTimeLabel.text = String(format: "-%d:%02d", remaining / 60, remaining % 60)
    }

    // MARK: - Layout
    private func setupConstraints(dismissIcon: UIButton) {
        // Removed shuffle and repeat constraints
        NSLayoutConstraint.activate([
            dismissIcon.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 10),
            dismissIcon.centerXAnchor.constraint(equalTo: view.centerXAnchor),
            
            albumArtContainer.topAnchor.constraint(equalTo: dismissIcon.bottomAnchor, constant: 40),
            albumArtContainer.centerXAnchor.constraint(equalTo: view.centerXAnchor),
            albumArtContainer.widthAnchor.constraint(equalTo: view.widthAnchor, multiplier: 0.85),
            albumArtContainer.heightAnchor.constraint(equalTo: albumArtContainer.widthAnchor),
            
            albumArt.topAnchor.constraint(equalTo: albumArtContainer.topAnchor),
            albumArt.leadingAnchor.constraint(equalTo: albumArtContainer.leadingAnchor),
            albumArt.trailingAnchor.constraint(equalTo: albumArtContainer.trailingAnchor),
            albumArt.bottomAnchor.constraint(equalTo: albumArtContainer.bottomAnchor),
            
            transcriptBox.topAnchor.constraint(equalTo: dismissIcon.bottomAnchor, constant: 40),
            transcriptBox.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 32),
            transcriptBox.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -32),
            transcriptBox.bottomAnchor.constraint(equalTo: titleLabel.topAnchor, constant: -40),
            
            transcriptTextView.topAnchor.constraint(equalTo: transcriptBox.topAnchor),
            transcriptTextView.leadingAnchor.constraint(equalTo: transcriptBox.leadingAnchor),
            transcriptTextView.trailingAnchor.constraint(equalTo: transcriptBox.trailingAnchor),
            transcriptTextView.bottomAnchor.constraint(equalTo: transcriptBox.bottomAnchor),
            
            titleLabel.topAnchor.constraint(equalTo: albumArtContainer.bottomAnchor, constant: 45),
            titleLabel.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 32),
            titleLabel.trailingAnchor.constraint(equalTo: moreBtn.leadingAnchor, constant: -10),
            titleLabel.heightAnchor.constraint(lessThanOrEqualToConstant: 60),
            
            moreBtn.centerYAnchor.constraint(equalTo: titleLabel.centerYAnchor),
            moreBtn.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -32),
            moreBtn.widthAnchor.constraint(equalToConstant: 30),
            moreBtn.heightAnchor.constraint(equalToConstant: 30),
            
            sourceLabel.topAnchor.constraint(equalTo: titleLabel.bottomAnchor, constant: 4),
            sourceLabel.leadingAnchor.constraint(equalTo: titleLabel.leadingAnchor),
            
            currentTimeLabel.topAnchor.constraint(equalTo: sourceLabel.bottomAnchor, constant: 25),
            currentTimeLabel.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 32),
            
            remainingTimeLabel.centerYAnchor.constraint(equalTo: currentTimeLabel.centerYAnchor),
            remainingTimeLabel.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -32),
            
            playbackSlider.topAnchor.constraint(equalTo: currentTimeLabel.bottomAnchor, constant: 8),
            playbackSlider.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 32),
            playbackSlider.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -32),
            
            playPauseBtn.topAnchor.constraint(equalTo: playbackSlider.bottomAnchor, constant: 45),
            playPauseBtn.centerXAnchor.constraint(equalTo: view.centerXAnchor),
            playPauseBtn.widthAnchor.constraint(equalToConstant: 60),
            playPauseBtn.heightAnchor.constraint(equalToConstant: 60),
            
            backwardBtn.centerYAnchor.constraint(equalTo: playPauseBtn.centerYAnchor),
            backwardBtn.trailingAnchor.constraint(equalTo: playPauseBtn.leadingAnchor, constant: -50),
            
            forwardBtn.centerYAnchor.constraint(equalTo: playPauseBtn.centerYAnchor),
            forwardBtn.leadingAnchor.constraint(equalTo: playPauseBtn.trailingAnchor, constant: 50),
            
            volumeSlider.topAnchor.constraint(equalTo: playPauseBtn.bottomAnchor, constant: 35),
            volumeSlider.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 45),
            volumeSlider.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -45),
            
            transcriptToggle.topAnchor.constraint(equalTo: volumeSlider.bottomAnchor, constant: 20),
            transcriptToggle.centerXAnchor.constraint(equalTo: view.centerXAnchor),
            transcriptToggle.widthAnchor.constraint(equalToConstant: 44),
            transcriptToggle.heightAnchor.constraint(equalToConstant: 44),
            transcriptToggle.bottomAnchor.constraint(lessThanOrEqualTo: view.safeAreaLayoutGuide.bottomAnchor, constant: -10)
        ])
    }
    
    deinit {
        stopPlayback()
        stopSpeech()
        do { try audioSession?.setActive(false) } catch { }
    }
}

// MARK: - AVSpeechSynthesizerDelegate
extension NewAudioPlayerViewController: AVSpeechSynthesizerDelegate {
    func speechSynthesizer(_ synthesizer: AVSpeechSynthesizer, didFinish utterance: AVSpeechUtterance) {
        DispatchQueue.main.async { self.handleTrackEnd() }
    }
}
